#include <BluetoothSerial.h>
#include <CircularBuffer.h>

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to enable it
#endif

#if !defined(CONFIG_BT_SPP_ENABLED)
#error Serial Bluetooth not available or not enabled. It is only available for the ESP32 chip.
#endif

BluetoothSerial SerialBT;

// 常量定义
const uint32_t GPS_BAUD_RATE = 115200;
const uint32_t SERIAL_BAUD_RATE = 115200;
const char* BT_DEVICE_NAME = "Air551G-GNSS";
const uint8_t LED_DATA_PIN = 13;
const uint8_t LED_ERROR_PIN = 12;
const uint16_t GPS_BUFFER_SIZE = 256;
const uint8_t GPS_RX_PIN = 16;
const uint8_t GPS_TX_PIN = 17;

// 全局变量
CircularBuffer<char, GPS_BUFFER_SIZE> gpsBuffer;
char nmeaSentence[GPS_BUFFER_SIZE];
uint32_t lastDataTime = 0;
const uint32_t DATA_TIMEOUT = 5000; // 5 seconds timeout

void setup() {
  // 初始化串口
  Serial.begin(SERIAL_BAUD_RATE);
  Serial2.begin(GPS_BAUD_RATE, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  
  // 初始化蓝牙
  SerialBT.begin(BT_DEVICE_NAME);
  Serial.println("Bluetooth device started, you can pair it with Bluetooth!");
  
  // 初始化LED引脚
  pinMode(LED_DATA_PIN, OUTPUT);
  pinMode(LED_ERROR_PIN, OUTPUT);
}

void loop() {
  if (millis() - lastDataTime > DATA_TIMEOUT) {
    logError("No GPS data received for 5 seconds");
    lastDataTime = millis();
  }

  // 读取GPS数据
  while (Serial2.available()) {
    char c = Serial2.read();
    gpsBuffer.push(c);
    lastDataTime = millis();
    
    if (c == '\n') {
      processNMEASentence();
    }
  }

  // 处理蓝牙接收到的数据（如果需要）
  while (SerialBT.available()) {
    Serial.write(SerialBT.read());
  }
}

void processNMEASentence() {
  uint16_t i = 0;
  while (!gpsBuffer.isEmpty() && i < GPS_BUFFER_SIZE - 1) {
    char c = gpsBuffer.shift();
    nmeaSentence[i++] = c;
    if (c == '\n') break;
  }
  nmeaSentence[i] = '\0';
  
  // 检查是否是有效的NMEA语句
  if (nmeaSentence[0] == '$' && i > 10) {  // 确保长度足够
    // 计算校验和
    if (validateChecksum(nmeaSentence)) {
      // 通过蓝牙发送数据
      digitalWrite(LED_DATA_PIN, HIGH);
      SerialBT.write((uint8_t*)nmeaSentence, i);
      digitalWrite(LED_DATA_PIN, LOW);
      
      // 在串口打印NMEA语句
      Serial.print(nmeaSentence);
    } else {
      logError("Invalid NMEA checksum");
    }
  }
}

bool validateChecksum(const char* sentence) {
  uint8_t checksum = 0;
  // 跳过'$'
  for (int i = 1; sentence[i] && sentence[i] != '*'; i++) {
    checksum ^= sentence[i];
  }
  
  char expectedChecksumStr[3];
  sprintf(expectedChecksumStr, "%02X", checksum);
  
  return (sentence[strlen(sentence)-4] == '*' &&
          sentence[strlen(sentence)-3] == expectedChecksumStr[0] &&
          sentence[strlen(sentence)-2] == expectedChecksumStr[1]);
}

void logError(const char* message) {
  static uint32_t lastErrorTime = 0;
  const uint32_t ERROR_COOLDOWN = 10000; // 10 seconds between error messages
  
  if (millis() - lastErrorTime > ERROR_COOLDOWN) {
    Serial.print("ERROR: ");
    Serial.println(message);
    digitalWrite(LED_ERROR_PIN, HIGH);
    delay(100);  // 短暂点亮LED
    digitalWrite(LED_ERROR_PIN, LOW);
    lastErrorTime = millis();
  }
}
